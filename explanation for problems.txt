for the first problem: 
basically i sorted the array and binary searched on the answer to see if it works. to see if it works i just iterated over the array and added the wait time to the ith index and saw if the current cows could be covered in 1 bus. if they can't then create a new bus and change currWait time to the new ith index cow + wait time. also keep track of the number of cows to see if they dont exceed the capacity, because if they do you create a new bus. at the end you return if the number of buses are less than are given bus value m.  this is done in O(n(logn))

the second problem:
this problem was brute force with custom comparators. first of all, i want to generate the orders in which the cows do the process. basicxally,in one set i sorted the cows based on their seniorirtiy value and on the other i sorted them on the arrival time. The seniroirty value sorted set is empty currently. and i also created a vector<set< for prioritty>>. then i just iterated over the arrivals time checked 2 cases: if the arrival of the cow is >= curr time (just store the arrival time + duration as curr time then), or the else case: (have a while loop which goes over every cow whose arrival time < curr time. because this is sorted i also incremementd i, which still kept the solution as O(n). so basically, of the cows whose arrival time is < curr time, you want to store them by their seniority value, because it is the same as them arriving at the same time cuz when the next cow is done, both of them would have nbeen waiting already. so i appended those cows onto the set and later put it onto a vector after i was done with the while loop. and for the sum, i made an observation that it was just them sum of the duration times. for example, in the sample case, a cow ended at 27, while 2 cows whose arrival times were 20 and 25 and whose durations were 50 and 3 were waiting. so basically the cow with more priority, whose arrival time was 25 would go first for 3 time units. the time would be 30, but the cow who was 20 would still be waiting. the cow who was 20 would go for 50 time units. so you can see the current time is just the durations of all the cows who were waiting plus the original current time. if no cows were waiting because the cow arrival time was >= curr time, then the curr time just equals cow arrival + cow duration. curr time starts at 0 also.  you can also compute wait time for the current cow by wait = max(wait, cow arrival-curr time). thats basically it. for me, this problem was a bit harder than the first one as i struggled with the implemenetation with but i eventually got it. Done in O(n)

the third problem
ok, so i found this problem to be easier than both of the other problems cuz it was just basic floodfill and some changes. basically you floodfill for all colors [1,9]. a connected component would be defined as the same color adjancent to another. so basically for each color you go over all of its connected components through floodfill and see if the size >= k, if so, turn all of those elements in the connected component to '0' after doing this, you have to account for gravity. because '0' is empty space like air, any color block can just fall through it. so basically you would get each column and get the first non zero block, remove every zero between/after it. then put those at the bottom, and fill the top with zeroes for all columns. and basically the idea is you cant perform this only once because after the gravity will cause blocks to fall, there might be a new connected component whose size >= k when they match. so you have to run it in a while loop. in it while loop my steps were. 1. floodfill for all [1,9]. 2. do the gravity effect. 3. then see if it is possible to do the floodfill after gravity before entering the next loop. although, i did not need step 3 cuz the floodfill function and gravity wont do any change if there are no changes in connected components <= k size. then i just printed out the grid. anyways, i found this problem pretty fun also because flood fill is one of my fav topics in silver. This was done in O(n) because floodfill is O(V*E), but we were guaranteed here that thw width of the graph is 10, so it becomes O(10n), removing the constants just makes it O(n)